"""
This file is a very crappy and heuristic way of plotting roughly the average distance
through generations.
The files for analysis were generated by saving the result of every call 
to the get_component_compatibility() method. This is probably not in the code anymore.
"""
# %%
# compat_modif = "raw"
compat_modif = "with_sqrt"

# comp_to = 1
# comp_to = 5
# comp_to = 10
comp_to = 20

filename = f"E:\\migrate_o\\github_repos\\EvolvePetriNets\\results\\test_compats_here\\{compat_modif}\\compare_to_{comp_to}.txt"

float_list = []

with open(filename, "r") as file:
    for line in file:
        try:
            float_value = float(line.strip())
            float_list.append(float_value)
        except ValueError:
            print(f"Invalid float value: {line.strip()}")

plt.boxplot(float_list, meanline=True, showmeans=True, patch_artist=True)
plt.title('Distribution of distances over run')

# %%
import numpy as np
import matplotlib.pyplot as plt

# Assuming float_list is the list obtained from the file
n_segments = 1000
segment_size = len(float_list) // n_segments
nested_list = [float_list[i * segment_size:(i + 1) * segment_size] for i in range(n_segments)]

# Handling the case where the last segment might be smaller
if len(float_list) % 10:
    nested_list[-1].extend(float_list[10 * segment_size:])

# Calculate the average of each segment
averages = [np.mean(segment) for segment in nested_list]

# Plotting
plt.scatter(range(len(averages)), averages, marker='o')
plt.title('Avg compat score calculated for all genomes per gen')
plt.xlabel('gen')
plt.ylabel('Average Value')
plt.grid(True)
plt.show()

# %%
"""
One-off for calculating the times of certain runs, could do this in endreports as well
"""
import pandas as pd
import datetime

data = {
    'sqrt_end_times': {
        'start_time': '18:41:43',
        '1_end_time': '19:47:22',
        '5_end_time': '19:55:09',
        '10_end_time': '19:57:14',
        '20_end_time': '19:58:59'
    },
    'raw_end_times': {
        'start_time': '20:11:22',
        '1_end_time': '21:16:52',
        '5_end_time': '21:19:40',
        '10_end_time': '21:17:57',
        '20_end_time': '21:17:32'
    }
}

# Convert to DataFrame
df = pd.DataFrame.from_dict(data)

# Convert to DataFrame
df = pd.DataFrame.from_dict(data)

# Function to convert time strings to timedelta objects
def time_to_timedelta(time_str):
    t = datetime.datetime.strptime(time_str, '%H:%M:%S')
    return datetime.timedelta(hours=t.hour, minutes=t.minute, seconds=t.second)

# Convert string times to timedelta objects
for column in df.columns:
    df[column] = df[column].apply(time_to_timedelta)

# Calculate durations for each column and store them in new columns
for key in ['sqrt_end_times', 'raw_end_times']:
    start_time = df.loc['start_time', key]
    # Subtract start_time from each end_time and convert the result to minutes
    df[key + '_delta'] = df[key].apply(lambda x: (x - start_time))

# Drop the start_time row as it's not needed for delta calculations
df.drop('start_time', inplace=True)

df
